---
id: lw8qwupj5w0yohuqytyp1aa
title: Webflux
desc: ''
updated: 1684607826727
created: 1684337305589
---

## Определение

Reactive programming - это неблокирующие приложения, которые являются асинхронными и управляемыми событиями и требуют небольшого количества потоков для масштабирования.

## Reactive Streams

Реактивные потоки - это небольшая спецификация, предназначенная для реализации реактивными библиотеками, созданными для JVM. Он определяет типы, которые необходимо реализовать для достижения взаимодействия между различными реализациями. Спецификация определяет взаимодействие между асинхронными компонентами с противодавлением. Реактивные потоки были реализованы в Java 9 в виде Flow API. Назначение Flow API - действовать как спецификация взаимодействия, а не API конечного пользователя, такого как RxJava.

### Основные типы спецификации

**Publisher:**  
 Он представляет производителя данных/источник данных и имеет один метод, который позволяет подписчику зарегистрироваться на издателе.

```java
public interface Publisher<T> {
    public void subscribe(Subscriber<? super T> s);
}
```

**Subscriber:**  
 Он представляет потребителя и имеет следующие методы:

```java
public interface Subscriber<T> {
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
```

- **onSubscribe** - должны вызываться Publisher перед началом обработки и использоватся для передачи на Subscription объекта от Publisher до Subscriber

- **onNext** - используется для того, чтобы сигнализировать о том, что был отправлен новый элемент

- **onError** - используется для того, чтобы сигнализировать о том, что произошел сбой Publisher и больше никаких элементов не будет

- **onComplete** - используется для того, чтобы сигнализировать, что все элементы были успешно отправлены

**Subscription:**
Subscription содержат методы, которые позволяют клиенту управлять выдачей элементов Publisher (т.е. обеспечивать поддержку противодавления).

```java
public interface Subscription {
public void request(long n);
public void cancel();
}
```

- **request** позволяет Subscriber сообщить, Publisher сколько дополнительных элементов будет опубликовано

- **cancel** позволяет подписчику отменить дальнейшую отправку элементов Publisher

**Processor:**
Если объект должен преобразовывать входящие элементы, а затем передавать их другому Subscriber, требуется реализация интерфейса Processor. Он действует и как Subscriber ,и как Publisher.

```java
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```

## Flux vs Mono

**Flux** - это Publisher, который может испускать от 0 до N элементов, а **Mono** может испускать от 0 до 1 элемента.  
Оба они завершаются либо сигналом завершения, либо ошибкой, и они вызывают методы onNext, onComplete и onError нижестоящего подписчика. Помимо реализации функций, описанных в спецификации Reactive Streams, Flux и Mono предоставляют набор операторов для поддержки преобразований, фильтрации и обработки ошибок.

## Типы операторов

| Категория оператора                                  | Примеры                                               |
| ---------------------------------------------------- | ----------------------------------------------------- |
| Создание новой последовательности                    | just, fromArray, fromIterable, fromStream             |
| Преобразование существующей последовательности       | map, flatMap, startWith, concatWith                   |
| Заглядывать в последовательность                     | doOnNext, doOnComplete, doOnError, doOnCancel         |
| Фильтрация последовательности                        | filter, ignoreElements, distinct, elementAt, takeLast |
| Обработка ошибок                                     | onErrorReturn, onErrorResume, retry                   |
| Работаем со временем                                 | elapsed, interval, timestamp, timeout                 |
| Расщепление потока                                   | buffer, groupBy, window                               |
| Возвращаясь к синхронному миру                       | block, blockFirst, blockLast, toIterable, toStream    |
| Многоадресная рассылка потока нескольким подписчикам | publish, cache, replay                                |

## Hot & Cold Publishers

Холодный Publisher генерирует новые данные для каждой подписки. Если подписки нет, данные никогда не генерируются.  
Напротив, hot издатель не зависит от подписчиков. Он может начать публикацию данных без подписчиков. Если подписчик подписывается после того, как издатель начал передавать значения, он получит только значения, выпущенные после его подписки.
