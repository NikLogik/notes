---
id: r59ro6t24t9rk1ruyg4twrp
title: "ElasticSearch"
desc: ""
updated: 1684665409161
created: 1668352541220
---

Elasticsearch — поисковый движок с json rest api, использующий Lucene и написанный на Java.
Документоориентированная база данных.

## Запросы

ES имеет две базовых группы запросов:

- filter query
- match query

Поиск и аггрегация результатов происходит отедльно на каждом шарде, реализуя модель распределенных вычислений **MapReduce**.

## Анализаторы

Анализаторы состоят из одного Tokenizer и нескольких необязательных TokenFilters.  
Tokenizer может предшествовать нескольким CharFilters. Tokenizer разбивают исходную строку на токены, например, по пробелам и символам пунктуации.  
TokenFilter может изменять токены, удалять или добавлять новые, например, оставлять только основу слова, убирать предлоги, добавлять синонимы.  
CharFilter — изменяет исходную строку целиком, например, вырезает html теги.

## Индексация

Обратный подход к стандартной индексации — собрать список всех используемых слов и узнать, в каких документах они встречаются.  
Даже если индексация займет больше времени, нас в первую очередь интересует именно скорость поиска, а не индексации.

Такой индекс называется обратным индексом и используется для полнотекстового поиска.

Хороший пример — популярная open-source библиотека полнотекстового поиска, конечно же, с обратным индексом, Apache Lucene.

![Обратный индекс](assets/images/inverted-index-2.png)

## Архитектура

Для обеспечения горизонтального масштабирования нам необходимо иметь возможность размещать данные на разных машинах.  
Важно чтобы мы имели единое логическое хранилище. Каждый инстанс Lucene должен стать частью одного большого индекса, или осколком(shard) разбитого индекса. Шард будет выполнять непосредственно операции по поиску и записи данных.

**Shard** в Elasticsearch — это логическая единица хранения данных на уровне базы, которая является отдельным экземпляром Lucene.

![](assets/images/es-index-sructure.png)

Для того, чтобы обращаться к распределенной системе шардов, нам необходимо иметь некий координирующий узел, именно он будет принимать запросы и давать задания на запись или получение данных. То есть помимо хранения данных мы выделяем еще один вариант поведения программы — координирование.

Таким образом мы изначально ориентируемся на два вида узлов — CRUD-узлы и координирующие узлы. Назовем их **data node** и **coordinating node**.

Каждый запущенный экземпляр Elasticsearch является отдельным узлом(node).

**Cluster** — это совокупность определенных нод. Когда вы запускаете один экземпляр ваш кластер будет состоять из одной ноды.

Для того чтобы объединить узлы в кластер они должны соответствовать ряду требований:

- Ноды должны иметь одинаковую версию
- Имя кластера cluster.name в конфигурации должно быть одинаковым

Конфигурация читается из файла elasticsearch.yml и переменных среды. Здесь мы можете настроить почти все, что касается неизменных в рантайме свойств ноды.

![](assets/images/es-cluster-structure.png)

## Репликация

Если мы потеряем одну из data-нод, то всегда сможем продолжить работу с репликами шардов в другом узле и тем временем вернуть потерянный.

То есть для каждого шарда должна быть как минимум одна копия на другой ноде. Можно конечно выделять по отдельной машине для каждой реплики, но это очень расточительно. Нужно разместить копии данных на разных узлах, но это не значит, что эти узлы должны хранить только шарды реплик.

![](assets/images/es-replicas-scheme.png)
